import L from "leaflet";
import { GéométrieOsm, LieuJson } from "./types.ts";
import { PourDjango, sommetMédian, Vecteur, LieuOsm, LieuAdresse, LieuSansType, ArgsLieuAdresse, ArgsLieuOsm } from "./lieux.ts";



export abstract class Lieu {

    static R_terre = 6360000; // en mètres
    static coeff_rad = Math.PI / 180; // Multiplier par ceci pour passer en radians

    coords: L.LatLng;
    leaflet_layer: L.Layer; // L’objet leaflet à dessiner sur la carte. (Sera un polyline pour les rues, un marqueur sinon.)
    nom: string;


    abstract pourDjango(): PourDjango;

    // Crée l’objet mais aussi un marqueur. Le marqueur n’est pas lié à la carte.
    constructor(géom: GéométrieOsm, nom: string) {
        this.coords = sommetMédian(géom);
        const icone = AwesomeMarkers.icon();
        this.leaflet_layer = new L.Marker(this.coords, { icon: icone });
        this.leaflet_layer.bindPopup(nom);
        this.nom = nom;
    }


    setLatlng(ll: L.LatLng) {
        this.coords = ll;
    }


    vecteurVers(autreLieu: Lieu) {
        return this.vecteurVersLatLng(autreLieu.coords);
    }

    vecteurVersLatLng(ll2: L.LatLng): Vecteur {
        const ll1 = this.coords;
        const dx = LieuOsm.R_terre * Math.cos(ll1.lat * Math.PI / 180) * (ll2.lng - ll1.lng) * Math.PI / 180;
        const dy = LieuOsm.R_terre * (ll2.lat - ll1.lat) * Math.PI / 180;
        return new Vecteur(dx, dy);
    }


    static from_json(données: LieuJson): Lieu {
        switch (données.type_étape) {
            case "adresse": {
                return new LieuAdresse(données as LieuSansType as ArgsLieuAdresse);
            }
            case "lieu": {
                return new LieuOsm(données as LieuSansType as ArgsLieuOsm);
            }
            default: {
                throw new Error(`Type non reconnu : ${données.type_étape} pour ${données.nom}`);
            }
        }
    }

}
